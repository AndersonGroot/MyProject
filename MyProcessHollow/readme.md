# 简称目标进程为【目标】，源可执行文件为【源】
编译环境：vs2019，多字节，x86，MT

## 0.判断是否被其他进程创建并传入【目标】和【源】两个参数
argc != 3就退出

## 1.创建【目标】并挂起
CreateProcess的第6个参数fdwCreate:CREATE_SUSPENDED

## 2.打开【源】
CreateFile的第一个参数为其他进程创建时传入的【源】

## 3.获取【源】大小
GetFileSize

## 4.为【源】申请内存
VirtualAlloc

## 5.读取【源】到内存
ReadFile

## 6.解析【源】的dos头
```cpp
pDosH = (PIMAGE_DOS_HEADER)image;
```

## 7.定位【源】的nt头
```cpp
pNtH = (PIMAGE_NT_HEADERS)((LPBYTE)image + pDosH->e_lfanew);
```

## 8.获取【目标】环境并定位映像基址
```cpp
GetThreadContext(pi.hThread, &ctx);
```

## 9.申请内存用以加载【源】的pe
【申请内存】的地址与【目标】和【源】的映像基址 三者之间的关系：
1.如果【目标】与【源】的映像基址相同：
可以直接在该地址处申请内存（需先卸载模块），三者一致，无需修改重定位表
2.如果【目标】与【源】的映像基址不同：
①可以直接在【源】的映像基址处申请内存（不用卸载模块），即【申请内存】的地址与【源】的映像基址 两者相同，无需修复重定位表；但【申请内存】的地址与【目标】的映像基址 两者不同，需要将【目标】的映像基址修复为申请的内存地址
②可以系统随机分配申请内存的地址（不用卸载模块），如果【申请内存】的地址与【源】的映像基址 两者不同，需要修复重定位表；【申请内存】的地址与【目标】的映像基址 两者不同，需要将【目标】的映像基址修复为申请的内存地址

即分为三种情况
①【目标】和【源】的映像基址相同，先卸载模块，再在【目标】的映像基址处申请内存（不修复【目标】映像基址和重定位表）
②【目标】和【源】的映像基址不同，在【源】的映像基址处申请内存（修复【目标】映像基址，不修复重定位表）
③【目标】和【源】的映像基址不同，系统随机分配申请内存的地址（修复【目标】映像基址，根据【源】的映像基址与申请内存的地址判断是否修复重定位表）

VirtualAllocEx

## 10.在申请的内存中加载pe头
WriteProcessMemory

## 11.再加载所有节表
节表个数
```cpp
pNtH->FileHeader.NumberOfSections
```

## 12.判断是否需要修复重定位表
修复重定位表

## 13.修复【目标】入口点为【源】的入口点
```cpp
ctx.Eax = (DWORD)pRealBase +
		pNt->OptionalHeader.AddressOfEntryPoint;
```

## 14.设置【目标】环境
SetThreadContext

## 15.恢复【目标】
ResumeThread